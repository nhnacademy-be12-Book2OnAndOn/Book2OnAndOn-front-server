<th:block th:fragment="commonHeader(currentUser, cartCount, sectionBlocks, featuredSections, showNav)"
          xmlns:th="http://www.thymeleaf.org">
    <header class="main-header">
        <div class="header-bar container">
            <button aria-label="카테고리 열기" class="hamburger" onclick="toggleSidebar()" type="button">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <div class="logo-wrap">
                <a class="logo-link" th:href="@{/}">
                    <img alt="Book2OnAndOn logo" class="logo-mark" src="/images/logo.png"
                         th:src="@{/images/logo.png}">
                    <span class="brand-name">Book2OnAndOn</span>
                </a>
            </div>

            <form class="global-search" method="get" th:action="@{/books/search}">
                <div class="group">
                    <button aria-label="검색"
                            style="background:none; border:none; padding:0; display:flex; align-items:center; cursor:pointer;"
                            type="submit">
                        <svg aria-hidden="true" class="icon" style="width: 20px; height: 20px;" viewBox="0 0 24 24">
                            <g>
                                <path d="M21.53 20.47l-3.66-3.66C19.195 15.24 20 13.214 20 11c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9c2.215 0 4.24-.804 5.808-2.13l3.66 3.66c.147.146.34.22.53.22s.385-.073.53-.22c.295-.293.295-.767.002-1.06zM3.5 11c0-4.135 3.365-7.5 7.5-7.5s7.5 3.365 7.5 7.5-3.365 7.5-7.5 7.5-7.5-3.365-7.5-7.5z"></path>
                            </g>
                        </svg>
                    </button>

                    <input autocomplete="off"
                           class="input"
                           inputmode="search"
                           name="keyword"
                           placeholder="책 제목, 저자, ISBN 검색..."
                           required
                           th:value="${condition?.keyword}"
                           type="text">

                    <button aria-label="검색어 삭제" class="btn-clear"
                            onclick="this.previousElementSibling.value = ''; this.previousElementSibling.focus();"
                            type="button"></button>
                    <button aria-label="검색어 삭제" class="btn-clear"
                            onclick="document.querySelector('.global-search .input').value = ''"
                            type="button"></button>
                </div>

            </form>

            <div class="header-actions">
                <div class="icon-buttons">
                    <a aria-label="장바구니" class="icon-btn cart" th:href="@{/cartpage}">
                        <i aria-hidden="true" class="fi fi-rs-cart"></i>
                        <span class="cart-count" data-cart-count th:text="${cartCount} ?: 0">0</span>
                    </a>
                </div>
                <th:block th:if="${currentUser == null}">
                    <button class="text-link user-name-btn" th:onclick="|location.href='@{/login}'|" type="button">로그인
                    </button>
                    <button class="solid-link" th:onclick="|location.href='@{/signup}'|" type="button">회원가입</button>
                </th:block>
                <th:block th:if="${currentUser != null}">
                    <button class="text-link user-name-btn"
                            th:onclick="|location.href='@{${#strings.contains(currentUser.role, 'ADMIN')} ? '/admin' : '/users/me'}'|"
                            th:text="${currentUser.nickname} + '님'" type="button">사용자님
                    </button>
                    <button class="text-link logout" th:onclick="|location.href='@{/logout}'|" type="button">로그아웃
                    </button>
                </th:block>
            </div>
        </div>

        <nav class="category-nav" th:if="${showNav}">
            <div class="container chip-list" th:if="${sectionBlocks != null and #lists.isNotEmpty(sectionBlocks)}">
                <a class="chip"
                   th:classappend="${iter.index == 0}? 'active' : ''"
                   th:each="block,iter : ${sectionBlocks}"
                   th:href="'#section-' + (${block.id} ?: ${iter.index})"
                   th:text="${block.title}">신간 도서</a>
            </div>
            <div class="container chip-list"
                 th:if="${(sectionBlocks == null or #lists.isEmpty(sectionBlocks)) and featuredSections != null}">
                <a class="chip active" href="#section-new">신간 도서</a>
                <a class="chip"
                   th:each="collection,iter : ${featuredSections}"
                   th:href="'#section-featured-' + ${iter.index}"
                   th:text="${collection.title} ?: '베스트 셀러'"></a>
            </div>
            <div class="container chip-list"
                 th:if="${(sectionBlocks == null or #lists.isEmpty(sectionBlocks)) and featuredSections == null}">
                <a class="chip active" href="#section-new">신간 도서</a>
                <a class="chip" href="#section-bestseller">베스트 셀러</a>
                <a class="chip" href="#section-bestseller-yesterday">어제 베스트 셀러</a>
                <a class="chip" href="#section-popular">인기 도서</a>
            </div>
        </nav>
    </header>

    <th:block th:replace="~{fragments/layout :: categorySidebar(${categories})}"></th:block>
    <script>
        // 회원 addToCart 요청 포맷 단일화
        function buildUserAddOpts(payload) {
            const baseHeaders = { "Content-Type": "application/json" };
            return {
                method: "POST",
                credentials: "include",
                headers: buildAuthHeaders(baseHeaders),
                body: payload
            };
        }

        // 비회원 addToCart 요청 포맷”이 단일화
        function buildGuestAddOpts(payload) {
            const guestId = (typeof window.ensureGuestId === "function") ? window.ensureGuestId() : null;
            // 선택 항목이 주문에 반영되도록 selected=true 보강
            try {
                const obj = JSON.parse(payload);
                if (obj && typeof obj === 'object' && !('selected' in obj)) {
                    obj.selected = true;
                    payload = JSON.stringify(obj);
                }
            } catch (e) {
                // ignore parse errors
            }
            return {
                method: "POST",
                credentials: "include",
                headers: {
                    "Content-Type": "application/json",
                    "X-Guest-Id": guestId,
                    "GUEST_ID": guestId
                },
                body: payload
            };
        }

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }

        function setCookie(name, value, days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${encodeURIComponent(value)}; path=/; expires=${date.toUTCString()}`;
        }

        function buildAuthHeaders(base = {}) {
            const token = getCookie('accessToken');
            if (!token) return base;

            // 쿠키에 "Bearer xxx" 형태로 들어오든, "xxx"로 들어오든 둘 다 처리
            const auth = token.startsWith('Bearer ') ? token : `Bearer ${token}`;
            return { ...base, 'Authorization': auth };
        }

        window.ensureGuestId = window.ensureGuestId || function ensureGuestId() {
            // 1) 기존 값 우선순위: localStorage(uuid) -> cookie(GUEST_ID) -> cookie(guestId)
            let gid = null;
            try {
                // localStorage 접근은 브라우저 정책에 따라 예외가 날 수 있어 try-catch
                gid = localStorage.getItem('uuid');
            } catch (e) {}

            // 2) localStorage에 없으면 쿠키에서 복구 시도
            if (!gid) gid = getCookie('GUEST_ID');
            if (!gid) gid = getCookie('guestId');

            // 없으면 생성
            if (!gid) {
                gid = `guest-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
            }

            // 3) 저장(둘 다)
            // 게이트웨이/서버가 대소문자 모두 참조할 가능성 대비해 두 가지 쿠키를 모두 심어둠
            try { localStorage.setItem('uuid', gid); } catch (e) {}
            setCookie('GUEST_ID', gid, 30);
            setCookie('guestId', gid, 30);

            return gid;
        };

        window.toggleSidebar = window.toggleSidebar || function () {
            const sidebar = document.getElementById('categorySidebar');
            const overlay = document.getElementById('sidebarOverlay');
            if (!sidebar || !overlay) return;
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        };

        // 하위 카테고리 토글이 다른 페이지에서도 동작하도록 글로벌로 보강
        window.toggleSubcategory = window.toggleSubcategory || function (row) {
            if (!row || row.dataset.hasChildren !== 'true') return;
            const item = row.closest('.category-item');
            if (!item) return;

            item.classList.toggle('open');
            const list = item.querySelector(':scope > .subcategory-list');
            if (!list) return;

            if (item.classList.contains('open')) {
                list.style.display = 'block';
                list.style.maxHeight = list.scrollHeight + 'px';
                const onEnd = (event) => {
                    if (event.target !== list) return;
                    if (item.classList.contains('open')) {
                        list.style.maxHeight = 'none';
                    }
                    list.removeEventListener('transitionend', onEnd);
                };
                list.addEventListener('transitionend', onEnd);
            } else {
                list.style.maxHeight = list.scrollHeight + 'px';
                requestAnimationFrame(() => {
                    list.style.maxHeight = '0';
                });
            }
        };

        // 페이지 어디서든 햄버거/닫기/오버레이 클릭을 처리하도록 위임
        if (!window.__sidebarDelegated) {
            window.__sidebarDelegated = true;
            document.addEventListener('click', function (e) {
                const toggleBtn = e.target.closest('.hamburger, .close-sidebar, #sidebarOverlay');
                if (!toggleBtn) return;
                if (typeof window.toggleSidebar === 'function') {
                    window.toggleSidebar();
                }
            });
        }

        const LIKE_STORAGE_KEY = 'likedBooks';

        const clearLikedStorage = () => {
            try {
                localStorage.removeItem(LIKE_STORAGE_KEY);
            } catch (e) {
                // ignore storage errors
            }
        };

        const readLikedBooks = () => {
            try {
                const raw = localStorage.getItem(LIKE_STORAGE_KEY);
                return raw ? JSON.parse(raw) : {};
            } catch (e) {
                return {};
            }
        };

        const writeLikedBooks = (data) => {
            try {
                localStorage.setItem(LIKE_STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                // ignore storage errors
            }
        };

        const updateLikeButtonFromStorage = () => {
            const likedMap = readLikedBooks();
            document.querySelectorAll('.like-btn[data-book-id]').forEach(btn => {
                const id = btn.dataset.bookId;
                const entry = likedMap[id];
                if (!entry) return;
                btn.classList.toggle('active', true);
                const countSpan = btn.querySelector('.like-count');
                if (countSpan && typeof entry.likeCount === 'number') {
                    countSpan.textContent = entry.likeCount;
                }
            });
        };

        // 전역 좋아요 토글 (어디서든 재사용)
        window.toggleLike = window.toggleLike || async function (btn, bookId) {
            if (!bookId) return;

            const token = getCookie('accessToken');

            const authHeader = token ? (token.startsWith('Bearer') ? token : 'Bearer ' + token) : '';

            try {
                const res = await fetch(`/front/books/${bookId}/likes`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': authHeader
                    },
                    credentials: 'include'
                });
                if (res.status === 401) {
                    if (confirm('로그인이 필요합니다. 로그인 페이지로 이동할까요?')) {
                        location.href = '/login';
                    }
                    return;
                }
                if (!res.ok) throw new Error(await res.text());
                const data = await res.json();
                const countSpan = btn?.querySelector('.like-count');
                if (btn) btn.classList.toggle('active', !!data.liked);
                let resolvedLikeCount = null;
                if (typeof data.likeCount === 'number') {
                    resolvedLikeCount = data.likeCount;
                } else if (countSpan) {
                    const currentCount = Number((countSpan.textContent || '0').replace(/[^0-9]/g, '')) || 0;
                    resolvedLikeCount = data.liked ? currentCount + 1 : Math.max(0, currentCount - 1);
                }
                if (countSpan && resolvedLikeCount !== null) {
                    countSpan.textContent = resolvedLikeCount;
                }
                if (btn) {
                    const likedMap = readLikedBooks();
                    const id = String(bookId);
                    if (data.liked) {
                        likedMap[id] = {
                            id: bookId,
                            title: btn.dataset.bookTitle || '',
                            authors: btn.dataset.bookAuthors || '',
                            thumbnail: btn.dataset.bookThumb || '',
                            priceSales: Number(btn.dataset.bookPriceSales) || 0,
                            priceStandard: Number(btn.dataset.bookPriceStandard) || 0,
                            likedAt: new Date().toISOString(),
                            likeCount: typeof data.likeCount === 'number' ? data.likeCount : (likedMap[id]?.likeCount || 0)
                        };
                    } else {
                        delete likedMap[id];
                    }
                    if (resolvedLikeCount !== null) {
                        if (!likedMap[id]) {
                            likedMap[id] = {id: bookId, likeCount: resolvedLikeCount};
                        } else {
                            likedMap[id].likeCount = resolvedLikeCount;
                        }
                    }
                    writeLikedBooks(likedMap);
                }
            } catch (e) {
                alert('좋아요 처리 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
                console.error(e);
            }
        };

        document.addEventListener('click', (event) => {
            const logoutTarget = event.target.closest('.logout-link, .text-link.logout');
            if (logoutTarget) {
                clearLikedStorage();
                // 로그아웃 시 서버는 세션/토큰을 무효화하지만, localStorage는 자동으로 지워지지 않는다.
                // 따라서 로그아웃 시 localStorage를 비워서 로그인 여부 판단 보조
                localStorage.removeItem('userId');
            }
        });

        const syncLikedButtonsFromServer = async () => {
            const token = getCookie('accessToken');
            if (!token) return;
            try {
                const res = await fetch('/users/me/likes/ids?page=0&size=100', {credentials: 'include'});
                if (!res.ok) return;
                const ids = await res.json();
                if (!Array.isArray(ids)) return;
                const idSet = new Set(ids.map(id => String(id)));
                document.querySelectorAll('.like-btn[data-book-id]').forEach(btn => {
                    const isLiked = idSet.has(btn.dataset.bookId);
                    btn.classList.toggle('active', isLiked);
                });
            } catch (e) {
                // ignore sync errors
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            updateLikeButtonFromStorage();
            syncLikedButtonsFromServer();
        });

        // 공용 장바구니 담기 로직 (회원/비회원 분기 + 바로 이동)
        window.addToCart = window.addToCart || async function (bookId, qty) {
            // 로그용
            const rid = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
            console.log('장바구니 시작!!!!!!!!!!!', rid, {bookId, qty, stack: new Error().stack});

            if (!bookId) return;
            const quantity = Number(qty) > 0 ? Number(qty) : 1;
            const payload = JSON.stringify({bookId: bookId, quantity});

            let res = null;
            // 쿠키 기준 판단은 신뢰 불가: accessToken 쿠키가 있어도 만료/무효일 수 있음.
            // 정답은 서버: “회원 요청이 가능한지”는 401/403 응답이 결정.
            // 결과적으로 프론트 상태 캐시 오류(토큰은 있는데 실제로는 비회원 처리되어야 하는 경우)를 제거.
            try {
                //2) 배지 증가 로직 제거 → 서버 요약값으로 동기화 -> 회원 요청에 guest 헤더가 섞이거나, 반대로 guest 요청에 auth 헤더가 섞이는 문제 차단
                // 2-1) 로그인일 때만 회원 장바구니
                res = await fetch("/cart/user/items", buildUserAddOpts(payload));
                console.log("[addToCart] user attempt", rid, res.status);

                // 2-2) 로그인인데도 401/403이면(만료 등) → 게스트 fallback
                if (res.status === 401 || res.status === 403) {
                    res = await fetch("/cart/guest/items", buildGuestAddOpts(payload));
                    console.log("[addToCart] fallback guest (auth fail)", rid, res.status);
                }

                if (!res.ok) {
                    // 서버 장애(5xx)**를 비회원 fallback으로 처리하면 중복 담기/상태 꼬임 위험
                    throw new Error(res.status === 503
                        ? "장바구니 서비스가 잠시 불안정합니다. 잠시 후 다시 시도해주세요."
                        : "장바구니 담기에 실패했습니다.");
                }

                const badge = document.querySelector("[data-cart-count]");
                if (badge) {
                    // 배지 증가 로직 제거 → 서버 요약값으로 동기화
                    // const current = parseInt(badge.textContent || "0", 10) || 0;
                    // badge.textContent = current + quantity;
                    await refreshCartBadgeViaSummary();
                    badge.style.display = "inline-flex";
                }

                if (confirm("장바구니에 담겼습니다. 장바구니로 이동할까요?")) {
                    location.href = "/cartpage";
                }
            } catch (e) {
                console.error(e);
                alert(e.message || "장바구니 담기 실패");
            } finally {
                if (res) console.log("[user response]", rid, res.status);
            }
        };

        // 헤더 장바구니 뱃지를 서버 기준으로 맞추기
        async function refreshCartBadgeViaSummary() {
            const badge = document.querySelector('[data-cart-count]');
            if (!badge) return;

            // 공통 헤더
            const baseHeaders = { 'Content-Type': 'application/json' };

            // 1) 무조건 user 먼저 시도 (토큰 유무로 분기하지 않음)
            try {
                const userRes = await fetch('/cart/user', {
                    method: 'GET',
                    headers: buildAuthHeaders(baseHeaders), // 토큰 읽히면 Authorization 포함, 안 읽히면 baseHeaders만
                    credentials: 'include'
                });

                if (userRes.ok) {
                    const data = await userRes.json();
                    const count = Number(
                        data.totalItemCount ??
                        data.itemCount ??
                        data.totalQuantity ??
                        (data.items?.length ?? 0)
                    ) || 0;

                    badge.textContent = String(count);
                    badge.style.display = count > 0 ? 'inline-flex' : 'none';
                    return;
                }

                // 인증 실패(401 / 403)이면 → 비회원 폴백
                if (userRes.status === 401 || userRes.status === 403) {
                    await fetchGuestAndUpdateBadge(badge, baseHeaders);
                    return;
                }

                // 기타 오류는 UI만 0 처리 (서비스 장애 등)
                badge.textContent = '0';
                badge.style.display = 'none';
                return;

            } catch (e) {
                // 네트워크/예외는 guest fallback
                await fetchGuestAndUpdateBadge(badge, baseHeaders);
            }
        }

        // 비회원 전용 뱃지 처리
        // -> 회원 뱃지 표시가 되면 계속 비회원 뱃지 표시가 사라져서 추가함
        async function fetchGuestAndUpdateBadge(badge, baseHeaders) {
            const gid = (typeof window.ensureGuestId === 'function') ? window.ensureGuestId() : null;
            if (!gid) {
                badge.textContent = '0';
                badge.style.display = 'none';
                return;
            }

            const guestRes = await fetch('/cart/guest', {
                method: 'GET',
                headers: { ...baseHeaders, 'X-Guest-Id': gid, 'GUEST_ID': gid },
                credentials: 'include'
            });

            if (!guestRes.ok) {
                badge.textContent = '0';
                badge.style.display = 'none';
                return;
            }

            const data = await guestRes.json();
            const count = Number(
                data.totalItemCount ??
                data.itemCount ??
                data.totalQuantity ??
                (data.items?.length ?? 0)
            ) || 0;

            badge.textContent = String(count);
            badge.style.display = count > 0 ? 'inline-flex' : 'none';
        }
        // 새로고침 직후 헤더 배지 초기값 오염 방지.
        document.addEventListener('DOMContentLoaded', refreshCartBadgeViaSummary);
    </script>
</th:block>

<th:block th:fragment="categorySidebar(categories)" xmlns:th="http://www.thymeleaf.org">
    <div class="overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>
    <aside class="category-sidebar" id="categorySidebar">
        <div class="sidebar-header">
            <h3>카테고리</h3>
            <button class="close-sidebar" onclick="toggleSidebar()" type="button">×</button>
        </div>
        <ul class="category-list">
            <th:block th:each="category : ${categories}">
                <th:block th:replace="~{fragments/category :: categoryBranch(${category}, 0)}"></th:block>
            </th:block>
        </ul>
    </aside>
</th:block>

<th:block th:fragment="commonFooter" xmlns:th="http://www.thymeleaf.org">
    <footer class="site-footer">
        <div class="container footer-grid">
            <div>
                <div class="logo-wrap light">
                    <a class="logo-link" th:href="@{/}">
                        <img alt="Book2OnAndOn logo" class="logo-mark" src="/images/logo.png"
                             th:src="@{/images/logo.png}">
                        <span class="brand-name">Book2OnAndOn</span>
                    </a>
                </div>
                <p>책으로 떠나는 무한한 여행, <br> 당신의 서재를 채워보세요.</p>
            </div>
            <div>
                <h4>고객센터</h4>
                <a th:href="@{/support}">자주 묻는 질문</a>
                <a th:href="@{/support/guide}">이용 안내</a>
                <a th:href="@{/support/exchange}">반품/교환 안내</a>
                <a th:href="@{/notice}">공지사항</a>
            </div>
            <div>
                <h4>카테고리</h4>
                <a th:href="@{/books/new}">신간도서</a>
                <a th:href="@{/books/bestseller}">베스트 셀러</a>
                <a th:href="@{/books/literature}">어제 베스트 셀러</a>
                <a th:href="@{/books/self}">인기 도서</a>
            </div>
            <div>
                <h4>회사 정보</h4>
                <a th:href="@{/company/about}">회사 소개</a>
                <a th:href="@{/terms}">이용약관</a>
                <a th:href="@{/privacy}">개인정보처리방침</a>
                <a th:href="@{/contact}">제휴 문의</a>
            </div>
        </div>
        <p class="copyright">© 2025 Book2OnAndOn. All rights reserved. <br> 도서 DB 제공 : 알라딘 인터넷서점(www.aladin.co.kr)</p>
    </footer>
    <div aria-label="최근 본 도서" class="recent-floating" id="recentFloating">
        <button class="recent-toggle" onclick="toggleRecentFloating()" type="button">최근 본 도서</button>
        <div class="recent-body">
            <div class="recent-head">
                <span>최근 본 도서</span>
                <button class="close-btn" onclick="toggleRecentFloating()" type="button">×</button>
            </div>
            <div class="recent-list" id="recentList">
                <p class="muted">불러오는 중...</p>
            </div>
        </div>
    </div>
    <script th:src="@{/js/script.js}"></script>
    <script>
        (function () {
            const floating = document.getElementById('recentFloating');
            const listEl = document.getElementById('recentList');
            const toggleBtn = floating?.querySelector('.recent-toggle');
            const bodyEl = floating?.querySelector('.recent-body');
            let suppressToggleOnce = false;

            window.toggleRecentFloating = function () {
                if (suppressToggleOnce) {
                    suppressToggleOnce = false;
                    return;
                }
                floating?.classList.toggle('open');
                adjustDropdownDirection();
            };

            async function loadRecentViews() {
                if (!listEl) return;
                let remote = [];
                try {
                    const res = await fetch('/api/books/recent-views');
                    if (res.ok) {
                        remote = await res.json();
                    }
                } catch (e) {
                    // ignore, fall back to local
                }
                const local = loadLocalRecent();
                const merged = mergeRecent(remote, local);
                renderRecent(merged);
            }

            function loadLocalRecent() {
                try {
                    const raw = localStorage.getItem('recentBooks');
                    if (!raw) return [];
                    const parsed = JSON.parse(raw);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (e) {
                    return [];
                }
            }

            function mergeRecent(remote, local) {
                const combined = [];
                const seen = new Set();
                [...(remote || []), ...(local || [])].forEach(b => {
                    if (!b || b.id == null) return;
                    if (seen.has(b.id)) return;
                    seen.add(b.id);
                    combined.push(b);
                });
                return combined.slice(0, 6);
            }

            function renderRecent(items) {
                if (!items || items.length === 0) {
                    listEl.innerHTML = '<p class="muted">최근 본 도서가 없습니다.</p>';
                    return;
                }
                listEl.innerHTML = items.map(book => {
                    const thumb = book.thumbnail || '/images/no-image.png';
                    const title = book.title || '제목 없음';
                    const author = Array.isArray(book.contributorNames) && book.contributorNames.length
                        ? book.contributorNames[0]
                        : '';
                    return `
                        <a class="recent-item" href="/books/${book.id}">
                            <img src="${thumb}" alt="${title}" onerror="this.src='/images/no-image.png'">
                            <div class="recent-meta">
                                <p class="title">${title}</p>
                                <p class="author">${author}</p>
                            </div>
                        </a>
                    `;
                }).join('');
            }

            document.addEventListener('DOMContentLoaded', loadRecentViews);

            // 드래그로 위치 이동
            (function enableDrag() {
                if (!floating || !toggleBtn) return;
                const STORAGE_KEY = 'recentFloatingPos';
                let drag = {active: false, offsetX: 0, offsetY: 0, moved: false, startX: 0, startY: 0};

                function applySavedPos() {
                    try {
                        const raw = localStorage.getItem(STORAGE_KEY);
                        if (!raw) {
                            setDefaultPos();
                            return;
                        }
                        const pos = JSON.parse(raw);
                        setPos(pos.left, pos.top);
                    } catch (e) {
                        setDefaultPos();
                    }
                }

                function setDefaultPos() {
                    const left = Math.max(16, window.innerWidth - 280);
                    const top = Math.max(80, window.innerHeight - 260);
                    setPos(left, top);
                }

                function setPos(left, top) {
                    const maxLeft = Math.max(0, window.innerWidth - floating.offsetWidth - 10);
                    const maxTop = Math.max(0, window.innerHeight - floating.offsetHeight - 10);
                    const clampedLeft = Math.min(Math.max(10, left), maxLeft);
                    const clampedTop = Math.min(Math.max(10, top), maxTop);
                    floating.style.left = clampedLeft + 'px';
                    floating.style.top = clampedTop + 'px';
                    floating.style.right = 'auto';
                    floating.style.bottom = 'auto';
                    adjustDropdownDirection();
                }

                toggleBtn.addEventListener('mousedown', (e) => {
                    drag.active = true;
                    const rect = floating.getBoundingClientRect();
                    drag.offsetX = e.clientX - rect.left;
                    drag.offsetY = e.clientY - rect.top;
                    drag.startX = e.clientX;
                    drag.startY = e.clientY;
                    drag.moved = false;
                    document.body.style.userSelect = 'none';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!drag.active) return;
                    if (!drag.moved) {
                        const dist = Math.abs(e.clientX - drag.startX) + Math.abs(e.clientY - drag.startY);
                        if (dist > 4) drag.moved = true;
                    }
                    setPos(e.clientX - drag.offsetX, e.clientY - drag.offsetY);
                });

                document.addEventListener('mouseup', () => {
                    if (!drag.active) return;
                    drag.active = false;
                    document.body.style.userSelect = '';
                    if (drag.moved) {
                        suppressToggleOnce = true; // 드래그 후 클릭 토글 방지
                    }
                    try {
                        const rect = floating.getBoundingClientRect();
                        localStorage.setItem(STORAGE_KEY, JSON.stringify({left: rect.left, top: rect.top}));
                    } catch (e) {
                        // ignore
                    }
                });

                window.addEventListener('resize', () => {
                    applySavedPos();
                    adjustDropdownDirection();
                });
                applySavedPos();
            })();

            function adjustDropdownDirection() {
                if (!floating || !bodyEl || !floating.classList.contains('open')) return;
                const rect = bodyEl.getBoundingClientRect();
                const overflow = rect.bottom > window.innerHeight - 8;
                floating.classList.toggle('drop-up', overflow);
            }
        })();
    </script>
</th:block>
